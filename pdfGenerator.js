const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

// Ensure output directory exists
function ensureOutputDir() {
    const outputDir = path.join(__dirname, 'generated-pdfs');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    return outputDir;
}

// Generate PDF with 2-column layout, bold title, 11pt font
async function generatePDF(song) {
    return new Promise((resolve, reject) => {
        try {
            const outputDir = ensureOutputDir();
            const fileName = `${song.title.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.pdf`;
            const filePath = path.join(outputDir, fileName);
            
            // Create PDF document - 8.5 x 11 inches (US Letter)
            const doc = new PDFDocument({
                size: [612, 792], // 8.5" x 11" in points (72 points per inch)
                margins: {
                    top: 50,
                    bottom: 50,
                    left: 40,
                    right: 40
                }
            });
            
            // Pipe to file
            doc.pipe(fs.createWriteStream(filePath));
            
            // Page dimensions
            const pageWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
            const columnWidth = (pageWidth - 20) / 2; // 20px gap between columns
            const leftColumnX = doc.page.margins.left;
            const rightColumnX = leftColumnX + columnWidth + 20;
            
            // Title - Bold and centered
            doc.fontSize(16)
               .font('Helvetica-Bold')
               .text(song.title.toUpperCase(), leftColumnX, doc.y, {
                   width: pageWidth,
                   align: 'center'
               });
            
            // Artist - Below title
            doc.fontSize(12)
               .font('Helvetica')
               .text(`by ${song.artist}`, leftColumnX, doc.y + 5, {
                   width: pageWidth,
                   align: 'center'
               });
            
            // Add some space
            doc.moveDown(2);
            
            // Set font for lyrics - 11pt as requested
            doc.fontSize(11)
               .font('Helvetica');
            
            // Flow text in columns like Microsoft Word
            const allLines = song.lyrics || [];
            renderInWordStyleColumns(doc, allLines, leftColumnX, rightColumnX, columnWidth);
            
            // Footer
            doc.fontSize(8)
               .font('Helvetica')
               .text(`Generated by Discord Song Bot - ${new Date().toLocaleDateString()}`, 
                     leftColumnX, doc.page.height - 30, {
                       width: pageWidth,
                       align: 'center'
                     });
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be written
            doc.on('end', () => {
                console.log(`✅ PDF generated: ${fileName}`);
                resolve(filePath);
            });
            
            doc.on('error', (error) => {
                console.error('PDF generation error:', error);
                reject(error);
            });
            
        } catch (error) {
            console.error('Error in generatePDF:', error);
            reject(error);
        }
    });
}

// Group lyrics into logical sections
function groupLyricsIntoSections(lyrics) {
    const sections = [];
    let currentSection = [];
    
    for (const line of lyrics) {
        const trimmedLine = line.trim();
        
        // If we hit a section header and have content, save current section
        if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']') && currentSection.length > 0) {
            sections.push([...currentSection]);
            currentSection = [line];
        } else {
            currentSection.push(line);
        }
    }
    
    // Add the last section
    if (currentSection.length > 0) {
        sections.push(currentSection);
    }
    
    return sections;
}

// Microsoft Word style column rendering - text flows from bottom of left to top of right
function renderInWordStyleColumns(doc, lines, leftColumnX, rightColumnX, columnWidth) {
    const pageHeight = doc.page.height;
    const bottomMargin = 100;
    const topMargin = 120; // Account for header space
    
    let currentX = leftColumnX;  // Start in left column
    let currentY = doc.y;
    let isRightColumn = false;
    let pageStartY = currentY; // Remember where this page started
    
    console.log(`📰 Starting columns: pageHeight=${pageHeight}, topMargin=${topMargin}, bottomMargin=${bottomMargin}`);
    console.log(`📰 Available height per page: ${pageHeight - topMargin - bottomMargin}`);
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        
        // Calculate height needed for this line
        let lineHeight = doc.currentLineHeight() + 2; // Base line height with padding
        
        // Add extra space for section headers
        if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            lineHeight += 5; // Extra space after headers
        }
        
        // Check if we would exceed the page bottom
        const wouldExceedPage = (currentY + lineHeight) > (pageHeight - bottomMargin);
        
        if (wouldExceedPage) {
            if (!isRightColumn) {
                // Move to right column
                console.log(`🔄 Moving to right column at line ${i}: "${trimmedLine.substring(0, 30)}..."`);
                currentX = rightColumnX;
                currentY = pageStartY; // Go back to top of page
                isRightColumn = true;
                
                // Check again if it fits in right column
                if ((currentY + lineHeight) > (pageHeight - bottomMargin)) {
                    // Still doesn't fit - need new page
                    console.log(`📄 Still doesn't fit in right column - new page needed`);
                    doc.addPage();
                    currentX = leftColumnX;
                    currentY = topMargin; // Start at proper top margin
                    pageStartY = currentY;
                    isRightColumn = false;
                }
            } else {
                // Already in right column and doesn't fit - new page
                console.log(`📄 New page needed at line ${i}: "${trimmedLine.substring(0, 30)}..."`);
                doc.addPage();
                currentX = leftColumnX;
                currentY = topMargin; // Start at proper top margin
                pageStartY = currentY;
                isRightColumn = false;
            }
        }
        
        // Now render the line at the calculated position
        doc.x = currentX;
        doc.y = currentY;
        
        console.log(`📍 Line ${i}: column=${isRightColumn ? 'right' : 'left'}, x=${currentX}, y=${currentY.toFixed(1)}, text="${trimmedLine.substring(0, 20)}..."`);
        
        // Render based on line type
        if (trimmedLine === '') {
            // Empty line - just move down less
            currentY += lineHeight / 2;
        } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            // Section headers - BOLD
            doc.font('Helvetica-Bold')
               .text(line, currentX, currentY, { width: columnWidth });
            doc.font('Helvetica');
            currentY += lineHeight;
        } else if (isChordLine(trimmedLine)) {
            // Chord lines - BOLD
            doc.font('Helvetica-Bold')
               .text(line, currentX, currentY, { width: columnWidth });
            doc.font('Helvetica');
            currentY += lineHeight;
        } else {
            // Lyrics - NORMAL font
            doc.font('Helvetica')
               .text(line, currentX, currentY, { width: columnWidth });
            currentY += lineHeight;
        }
        
        // Update doc.y to current position
        doc.y = currentY;
    }
    
    console.log(`✅ Rendering complete. Total lines: ${lines.length}, Final column: ${isRightColumn ? 'right' : 'left'}, Final Y: ${currentY.toFixed(1)}`);
}

// Estimate section height for column distribution
function estimateSectionHeight(section, doc, width) {
    let height = 0;
    const lineHeight = doc.currentLineHeight();
    
    for (const line of section) {
        const trimmedLine = line.trim();
        
        if (trimmedLine === '') {
            height += lineHeight * 0.5; // Empty line spacing
        } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            height += lineHeight * 1.5; // Section header with extra space
        } else {
            height += lineHeight;
        }
    }
    
    height += lineHeight; // Extra space after section
    return height;
}

// Distribute sections with smart splitting always enabled
function distributeIntoColumns(sections, doc, columnWidth) {
    // Calculate available height from current Y position to bottom of page
    const currentY = doc.y;
    const bottomMargin = 80; // Leave room for footer
    const availableHeight = doc.page.height - currentY - bottomMargin;
    
    // Calculate total height of all sections
    const totalHeight = sections.reduce((sum, section) => {
        return sum + estimateSectionHeight(section, doc, columnWidth);
    }, 0);
    
    console.log(`📄 Page distribution: currentY=${currentY}, availableHeight=${availableHeight}, totalHeight=${totalHeight}`);
    
    // Always use smart distribution with splitting capability
    console.log(`🧠 Using smart distribution with section splitting enabled`);
    return distributeWithSmartSplitting(sections, doc, columnWidth, availableHeight);
}

// Unified smart distribution with intelligent section splitting
function distributeWithSmartSplitting(sections, doc, columnWidth, availableHeight) {
    let leftHeight = 0;
    let rightHeight = 0;
    const leftSections = [];
    const rightSections = [];
    
    for (const section of sections) {
        const sectionHeight = estimateSectionHeight(section, doc, columnWidth);
        const remainingLeftSpace = availableHeight - leftHeight;
        const remainingRightSpace = availableHeight - rightHeight;
        
        console.log(`📐 Processing section: height=${sectionHeight}, leftSpace=${remainingLeftSpace}, rightSpace=${remainingRightSpace}`);
        
        // Try to fit in left column first
        if (sectionHeight <= remainingLeftSpace) {
            leftSections.push(section);
            leftHeight += sectionHeight;
            console.log(`📝 Whole section to LEFT: height=${sectionHeight}, leftTotal=${leftHeight}`);
        }
        // Try to fit in right column
        else if (sectionHeight <= remainingRightSpace) {
            rightSections.push(section);
            rightHeight += sectionHeight;
            console.log(`📝 Whole section to RIGHT: height=${sectionHeight}, rightTotal=${rightHeight}`);
        }
        // Section doesn't fit entirely anywhere - try smart splitting
        else {
            console.log(`🔄 Section too big for either column - attempting smart split`);
            const splitResult = trySplitSection(section, doc, columnWidth, remainingLeftSpace, remainingRightSpace);
            
            if (splitResult.canSplit) {
                // Add split parts to respective columns
                if (splitResult.leftPart.length > 0) {
                    leftSections.push(splitResult.leftPart);
                    leftHeight += splitResult.leftHeight;
                    console.log(`✂️ Section split - LEFT part: ${splitResult.leftPart.length} lines, height=${splitResult.leftHeight}`);
                }
                if (splitResult.rightPart.length > 0) {
                    rightSections.push(splitResult.rightPart);
                    rightHeight += splitResult.rightHeight;
                    console.log(`✂️ Section split - RIGHT part: ${splitResult.rightPart.length} lines, height=${splitResult.rightHeight}`);
                }
            } else {
                // Can't split - this will trigger a page break in rendering
                console.log(`⚠️ Cannot split section intelligently - will need page break`);
                // Put in right column as it's likely to have more space after left column content
                rightSections.push(section);
                rightHeight += sectionHeight;
            }
        }
    }
    
    console.log(`📊 Final distribution: ${leftSections.length} left (${leftHeight}), ${rightSections.length} right (${rightHeight})`);
    return { leftSections, rightSections };
}

// Smart section splitting - ensures at least 30% content in first column
function trySplitSection(section, doc, columnWidth, leftSpace, rightSpace) {
    const minLeftPercentage = 0.30; // At least 30% must stay in left column
    const sectionLines = section.length;
    const minLeftLines = Math.ceil(sectionLines * minLeftPercentage);
    
    // Calculate height for minimum left portion (30%)
    const minLeftPortion = section.slice(0, minLeftLines);
    const minLeftHeight = estimateSectionHeight(minLeftPortion, doc, columnWidth);
    
    // If even 30% doesn't fit in left space, don't split
    if (minLeftHeight > leftSpace) {
        console.log(`� Can't split - even 30% (${minLeftLines} lines) too big for left space`);
        return { canSplit: false };
    }
    
    // Find optimal split point - as much as possible in left while staying within space
    let bestSplitIndex = minLeftLines; // Start with minimum 30%
    
    for (let i = minLeftLines + 1; i <= sectionLines; i++) {
        const leftPortion = section.slice(0, i);
        const leftHeight = estimateSectionHeight(leftPortion, doc, columnWidth);
        
        if (leftHeight <= leftSpace) {
            bestSplitIndex = i; // This split point works
        } else {
            break; // Stop - this would exceed left space
        }
    }
    
    // Create the split
    const leftPart = section.slice(0, bestSplitIndex);
    const rightPart = section.slice(bestSplitIndex);
    
    const leftHeight = estimateSectionHeight(leftPart, doc, columnWidth);
    const rightHeight = estimateSectionHeight(rightPart, doc, columnWidth);
    
    // Verify right part fits in right column
    if (rightHeight > rightSpace) {
        console.log(`🚫 Can't split - right part too big for right space`);
        return { canSplit: false };
    }
    
    console.log(`✅ Smart split: ${leftPart.length}/${rightPart.length} lines (${(leftPart.length/sectionLines*100).toFixed(1)}%/${(rightPart.length/sectionLines*100).toFixed(1)}%)`);
    
    return {
        canSplit: true,
        leftPart,
        rightPart,
        leftHeight,
        rightHeight
    };
}

// Fallback: sequential distribution with overflow protection
function distributeWithOverflow(sections, doc, columnWidth, availableHeight) {
    let currentHeight = 0;
    const leftSections = [];
    const rightSections = [];
    let useRightColumn = false;
    
    for (const section of sections) {
        const sectionHeight = estimateSectionHeight(section, doc, columnWidth);
        
        // If this section would overflow the current column, switch to right column
        if (!useRightColumn && currentHeight + sectionHeight > availableHeight) {
            console.log(`🔄 Switching to right column - section too tall for left`);
            useRightColumn = true;
            currentHeight = 0; // Reset height for right column
        }
        
        // Add section to appropriate column in original order
        if (useRightColumn) {
            rightSections.push(section);
        } else {
            leftSections.push(section);
        }
        
        currentHeight += sectionHeight;
    }
    
    console.log(`📊 Sequential distribution: ${leftSections.length} left sections, ${rightSections.length} right sections`);
    return { leftSections, rightSections };
}

// Render sections with minimal page breaks - let distribution handle the layout
function renderSections(doc, sections, columnX, columnWidth) {
    for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Only add page break if section is truly massive and would break the page
        const sectionHeight = estimateSectionHeight(section, doc, columnWidth);
        const bottomMargin = 50; // Reduced margin for less aggressive breaks
        
        // Only break page for very large sections that absolutely won't fit
        if (sectionHeight > 400 && doc.y + sectionHeight > doc.page.height - bottomMargin) {
            console.log(`⚠️ Very large section ${i} needs page break (height: ${sectionHeight})`);
            doc.addPage();
        }
        
        // Add space before section (except first one and after page break)
        if (i > 0 && doc.y > 100) { // 100 = roughly header area
            doc.moveDown(1);
        }
        
        for (const line of section) {
            const trimmedLine = line.trim();
            
            if (trimmedLine === '') {
                // Empty line - small space
                doc.moveDown(0.3);
            } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                // Section headers - BOLD (as requested)
                doc.font('Helvetica-Bold')
                   .text(line, columnX, doc.y, { width: columnWidth });
                doc.font('Helvetica');
                doc.moveDown(0.2);
            } else if (isChordLine(trimmedLine)) {
                // Chord lines - BOLD (as requested)
                doc.font('Helvetica-Bold')
                   .text(line, columnX, doc.y, { width: columnWidth });
                doc.font('Helvetica');
            } else {
                // Lyrics - NORMAL font (as requested)
                doc.font('Helvetica')
                   .text(line, columnX, doc.y, { width: columnWidth });
            }
        }
    }
}

// Check if a line contains chords - Simplified and more accurate
function isChordLine(line) {
    const trimmed = line.trim();
    
    // Empty lines are not chord lines
    if (trimmed.length === 0) return false;
    
    // Section headers are not chord lines
    if (trimmed.startsWith('[') && trimmed.endsWith(']')) return false;
    
    // Simple chord patterns - much more permissive
    const basicChordPattern = /\b[A-G][#b]?(m|maj|min|sus|aug|dim|add|[0-9])*\b/g;
    const chordMatches = trimmed.match(basicChordPattern);
    
    if (!chordMatches) return false;
    
    // Count words in the line
    const words = trimmed.split(/\s+/).filter(word => word.length > 0);
    const chordCount = chordMatches.length;
    
    // Very simple rules:
    // 1. If more than half the words are chords, it's a chord line
    // 2. If it's a short line (≤ 20 chars) with any chords, it's probably chords
    // 3. If it has 2+ chords and no common lyrics words, it's chords
    
    const chordRatio = chordCount / words.length;
    const isShort = trimmed.length <= 20;
    const hasCommonLyrics = /\b(the|and|you|me|my|i|a|to|in|is|of|for|with|will|love|lord|jesus|your|than|all|name)\b/i.test(trimmed);
    
    // Chord line if:
    return (chordRatio >= 0.5) ||                    // More than half words are chords
           (isShort && chordCount >= 1) ||          // Short line with any chords
           (chordCount >= 2 && !hasCommonLyrics);   // Multiple chords, no lyrics words
}

module.exports = {
    generatePDF,
    groupLyricsIntoSections,
    estimateSectionHeight,
    distributeIntoColumns,
    renderSections,
    isChordLine
};
