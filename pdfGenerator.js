const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

// Ensure output directory exists
function ensureOutputDir() {
    const outputDir = path.join(__dirname, 'generated-pdfs');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    return outputDir;
}

// Generate PDF with 2-column layout, bold title, 11pt font
async function generatePDF(song) {
    return new Promise((resolve, reject) => {
        try {
            const outputDir = ensureOutputDir();
            const fileName = `${song.title.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.pdf`;
            const filePath = path.join(outputDir, fileName);
            
            // Create PDF document - 8.5 x 11 inches (US Letter)
            const doc = new PDFDocument({
                size: [612, 792], // 8.5" x 11" in points (72 points per inch)
                margins: {
                    top: 50,
                    bottom: 50,
                    left: 40,
                    right: 40
                }
            });
            
            // Pipe to file
            doc.pipe(fs.createWriteStream(filePath));
            
            // Page dimensions
            const pageWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
            const columnWidth = (pageWidth - 20) / 2; // 20px gap between columns
            const leftColumnX = doc.page.margins.left;
            const rightColumnX = leftColumnX + columnWidth + 20;
            
            // Title - Bold and centered
            doc.fontSize(16)
               .font('Helvetica-Bold')
               .text(song.title.toUpperCase(), leftColumnX, doc.y, {
                   width: pageWidth,
                   align: 'center'
               });
            
            // Artist - Below title
            doc.fontSize(12)
               .font('Helvetica')
               .text(`by ${song.artist}`, leftColumnX, doc.y + 5, {
                   width: pageWidth,
                   align: 'center'
               });
            
            // Add some space
            doc.moveDown(2);
            
            // Set font for lyrics - 11pt as requested
            doc.fontSize(11)
               .font('Helvetica');
            
            // Process lyrics into sections for intelligent column splitting
            const sections = groupLyricsIntoSections(song.lyrics || []);
            
            // Intelligent column distribution
            const { leftSections, rightSections } = distributeIntoColumns(sections, doc, columnWidth);
            
            // Current Y position for both columns
            let currentY = doc.y;
            const startY = currentY;
            
            // Render Left Column
            doc.x = leftColumnX;
            doc.y = currentY;
            renderSections(doc, leftSections, leftColumnX, columnWidth);
            
            // Render Right Column
            doc.x = rightColumnX;
            doc.y = startY;
            renderSections(doc, rightSections, rightColumnX, columnWidth);
            
            // Footer
            doc.fontSize(8)
               .font('Helvetica')
               .text(`Generated by Discord Song Bot - ${new Date().toLocaleDateString()}`, 
                     leftColumnX, doc.page.height - 30, {
                       width: pageWidth,
                       align: 'center'
                     });
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be written
            doc.on('end', () => {
                console.log(`âœ… PDF generated: ${fileName}`);
                resolve(filePath);
            });
            
            doc.on('error', (error) => {
                console.error('PDF generation error:', error);
                reject(error);
            });
            
        } catch (error) {
            console.error('Error in generatePDF:', error);
            reject(error);
        }
    });
}

// Group lyrics into logical sections
function groupLyricsIntoSections(lyrics) {
    const sections = [];
    let currentSection = [];
    
    for (const line of lyrics) {
        const trimmedLine = line.trim();
        
        // If we hit a section header and have content, save current section
        if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']') && currentSection.length > 0) {
            sections.push([...currentSection]);
            currentSection = [line];
        } else {
            currentSection.push(line);
        }
    }
    
    // Add the last section
    if (currentSection.length > 0) {
        sections.push(currentSection);
    }
    
    return sections;
}

// Estimate section height for column distribution
function estimateSectionHeight(section, doc, width) {
    let height = 0;
    const lineHeight = doc.currentLineHeight();
    
    for (const line of section) {
        const trimmedLine = line.trim();
        
        if (trimmedLine === '') {
            height += lineHeight * 0.5; // Empty line spacing
        } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            height += lineHeight * 1.5; // Section header with extra space
        } else {
            height += lineHeight;
        }
    }
    
    height += lineHeight; // Extra space after section
    return height;
}

// Intelligently distribute sections into columns
function distributeIntoColumns(sections, doc, columnWidth) {
    const maxColumnHeight = doc.page.height - 150; // Leave room for header/footer
    let leftHeight = 0;
    let rightHeight = 0;
    const leftSections = [];
    const rightSections = [];
    
    for (const section of sections) {
        const sectionHeight = estimateSectionHeight(section, doc, columnWidth);
        
        // If adding to left column would exceed 50% and not break a section badly
        if (leftHeight + sectionHeight > maxColumnHeight * 0.6 && rightHeight === 0) {
            // Start right column
            rightSections.push(section);
            rightHeight += sectionHeight;
        } else if (leftHeight <= rightHeight) {
            // Add to left column
            leftSections.push(section);
            leftHeight += sectionHeight;
        } else {
            // Add to right column
            rightSections.push(section);
            rightHeight += sectionHeight;
        }
    }
    
    return { leftSections, rightSections };
}

// Render sections with proper formatting
function renderSections(doc, sections, columnX, columnWidth) {
    for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Add space before section (except first one)
        if (i > 0) {
            doc.moveDown(1);
        }
        
        for (const line of section) {
            const trimmedLine = line.trim();
            
            if (trimmedLine === '') {
                // Empty line - small space
                doc.moveDown(0.3);
            } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                // Section headers - bold
                doc.font('Helvetica-Bold')
                   .text(line, columnX, doc.y, { width: columnWidth });
                doc.font('Helvetica');
                doc.moveDown(0.2);
            } else if (isChordLine(trimmedLine)) {
                // Chord lines - regular weight (not bold as requested)
                doc.font('Helvetica')
                   .text(line, columnX, doc.y, { width: columnWidth });
            } else {
                // Lyrics - bold as requested
                doc.font('Helvetica-Bold')
                   .text(line, columnX, doc.y, { width: columnWidth });
                doc.font('Helvetica');
            }
        }
    }
}

// Check if a line contains chords
function isChordLine(line) {
    // Look for chord patterns: single letters, with optional modifiers
    const chordPattern = /^[A-G]([#b]?)(\w*)\s*([A-G]([#b]?)(\w*)\s*)*$/;
    const hasChordIndicators = /\b[A-G][#b]?(m|maj|min|sus|aug|dim|add|[0-9])*\b/.test(line);
    
    // Must be short-ish line with chord patterns and not contain common lyric words
    return line.length < 50 && 
           hasChordIndicators && 
           !/\b(the|and|you|me|my|i|a|to|in|is|of|for|with)\b/i.test(line);
}

module.exports = {
    generatePDF,
    groupLyricsIntoSections,
    estimateSectionHeight,
    distributeIntoColumns,
    renderSections,
    isChordLine
};
