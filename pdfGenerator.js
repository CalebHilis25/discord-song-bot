const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');
const { PDFDocument: PDFLib, rgb } = require('pdf-lib');

// Ensure output directory exists
function ensureOutputDir() {
    const outputDir = path.join(__dirname, 'generated-pdfs');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    return outputDir;
}

// Generate PDF with 2-column layout, bold title, 11pt font
async function generatePDF(song) {
    return new Promise((resolve, reject) => {
        try {
            const outputDir = ensureOutputDir();
            const fileName = `${song.title.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.pdf`;
            const filePath = path.join(outputDir, fileName);
            
            // Create PDF document - 8.5 x 11 inches (US Letter)
            const doc = new PDFDocument({
                size: [612, 792], // 8.5" x 11" in points (72 points per inch)
                margins: {
                    top: 50,
                    bottom: 70, // Increased for footer space
                    left: 40,
                    right: 40
                }
            });
            
            // Pipe to file
            doc.pipe(fs.createWriteStream(filePath));
            
            // Page dimensions
            const pageWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
            const columnWidth = (pageWidth - 20) / 2; // 20px gap between columns
            const leftColumnX = doc.page.margins.left;
            const rightColumnX = leftColumnX + columnWidth + 20;
            
            // Title - Bold and centered
            doc.fontSize(16)
               .font('Helvetica-Bold')
               .text(song.title.toUpperCase(), leftColumnX, doc.y, {
                   width: pageWidth,
                   align: 'center'
               });
            
            // Artist - Below title
            doc.fontSize(12)
               .font('Helvetica')
               .text(`by ${song.artist}`, leftColumnX, doc.y + 5, {
                   width: pageWidth,
                   align: 'center'
               });
            
            // Add some space
            doc.moveDown(2);
            
            // Flow text in columns like Microsoft Word with section spacing
            const allLines = song.lyrics || [];
            const linesWithSpacing = addSectionSpacing(allLines);
            const { pageCount, pageReferences } = renderInWordStyleColumns(doc, linesWithSpacing, leftColumnX, rightColumnX, columnWidth, pageWidth);
            
            // Add footers to all pages using the stored references
            addFootersToAllPagesWithReferences(doc, pageWidth, leftColumnX, pageCount, pageReferences);
            
            // Finalize PDF
            doc.end();
            
            // Wait for PDF to be written
            doc.on('end', () => {
                console.log(`‚úÖ PDF generated with footers: ${fileName}`);
                resolve(filePath);
            });
            
            doc.on('error', (error) => {
                console.error('PDF generation error:', error);
                reject(error);
            });
            
        } catch (error) {
            console.error('Error in generatePDF:', error);
            reject(error);
        }
    });
}

// Add footers to all pages using stored page references
function addFootersToAllPagesWithReferences(doc, pageWidth, leftColumnX, pageCount, pageReferences) {
    console.log(`üìÑ Adding footers to ${pageCount} pages using stored references`);
    
    if (pageCount === 0 || pageReferences.length === 0) {
        console.log('‚ö†Ô∏è No pages found to add footers to');
        return;
    }
    
    // Save current state
    const currentPage = doc.page;
    const currentY = doc.y;
    const currentFont = doc._font;
    const currentFontSize = doc._fontSize;
    
    // Add footers to each page using the stored references
    for (let i = 0; i < pageReferences.length; i++) {
        try {
            // Set the page directly
            doc.page = pageReferences[i];
            
            // Calculate footer position (absolute bottom of page)
            const footerY = doc.page.height - 40; // 40px from bottom
            
            // Set font for footer
            doc.fontSize(8)
               .font('Helvetica');
            
            // Add footer text on the left
            doc.text(`Generated by Discord Song Bot - 9/11/2025`, 
                     leftColumnX, footerY, {
                       width: pageWidth * 0.6,
                       align: 'left',
                       lineBreak: false
                     });
            
            // Add page number on the right
            doc.text(`${i + 1}/${pageCount}`, 
                     leftColumnX + (pageWidth * 0.6), footerY, {
                       width: pageWidth * 0.4,
                       align: 'right',
                       lineBreak: false
                     });
            
            console.log(`‚úÖ Added footer to page ${i + 1}/${pageCount}`);
            
        } catch (error) {
            console.error(`‚ùå Error adding footer to page ${i + 1}:`, error.message);
        }
    }
    
    // Restore original state
    try {
        doc.page = currentPage;
        doc.y = currentY;
        doc.fontSize(currentFontSize);
        if (currentFont) {
            doc.font(currentFont.name || 'Helvetica');
        }
    } catch (error) {
        console.log('‚ö†Ô∏è Could not restore state:', error.message);
    }
    
    console.log(`‚úÖ Completed adding footers with page numbering format: 1/${pageCount}, 2/${pageCount}, etc.`);
}

// Add footers to all pages with correct page numbering (1/3, 2/3, etc.)
function addFootersToAllPages(doc, pageWidth, leftColumnX, pageCount) {
    console.log(`üìÑ Adding footers to ${pageCount} pages`);
    
    if (pageCount === 0) {
        console.log('‚ö†Ô∏è No pages found to add footers to');
        return;
    }
    
    // Save current state
    const currentY = doc.y;
    const currentFont = doc._font;
    const currentFontSize = doc._fontSize;
    
    // Add footers to each page
    for (let pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        try {
            // For the first page, we can use the current page
            // For subsequent pages, we need to switch to them
            if (pageIndex > 0) {
                doc.switchToPage(pageIndex);
            }
            
            // Calculate footer position (absolute bottom of page)
            const footerY = doc.page.height - 40; // 40px from bottom
            
            // Set font for footer
            doc.fontSize(8)
               .font('Helvetica');
            
            // Add footer text on the left
            doc.text(`Generated by Discord Song Bot - 9/11/2025`, 
                     leftColumnX, footerY, {
                       width: pageWidth * 0.6,
                       align: 'left',
                       lineBreak: false
                     });
            
            // Add page number on the right
            doc.text(`${pageIndex + 1}/${pageCount}`, 
                     leftColumnX + (pageWidth * 0.6), footerY, {
                       width: pageWidth * 0.4,
                       align: 'right',
                       lineBreak: false
                     });
            
            console.log(`‚úÖ Added footer to page ${pageIndex + 1}/${pageCount}`);
            
        } catch (error) {
            console.error(`‚ùå Error adding footer to page ${pageIndex + 1}:`, error.message);
        }
    }
    
    // Restore original state
    try {
        doc.fontSize(currentFontSize);
        if (currentFont) {
            doc.font(currentFont.name || 'Helvetica');
        }
        // Don't restore Y position as we're adding footers
    } catch (error) {
        console.log('‚ö†Ô∏è Could not restore state:', error.message);
    }
    
    console.log(`‚úÖ Completed adding footers with page numbering format: 1/${pageCount}, 2/${pageCount}, etc.`);
}

// Add spacing between song sections (3 empty lines between each section block)
function addSectionSpacing(lines) {
    const linesWithSpacing = [];
    
    for (let i = 0; i < lines.length; i++) {
        const currentLine = lines[i];
        const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
        const trimmedCurrent = currentLine.trim();
        const trimmedNext = nextLine.trim();
        
        // Add current line
        linesWithSpacing.push(currentLine);
        
        // Add spacing after section blocks (when next line is a section header)
        if (trimmedCurrent !== '' && trimmedNext !== '') {
            if (trimmedNext.startsWith('[') && trimmedNext.endsWith(']')) {
                // Next line is a new section header, add 3 empty lines for more spacing
                linesWithSpacing.push(''); // Empty line 1
                linesWithSpacing.push(''); // Empty line 2
                linesWithSpacing.push(''); // Empty line 3
                console.log(`üìè Added 3 lines of section spacing after: "${trimmedCurrent.substring(0, 30)}..."`);
            }
        }
    }
    
    console.log(`‚ú® Added section spacing: ${lines.length} ‚Üí ${linesWithSpacing.length} lines`);
    return linesWithSpacing;
}

// Simple Microsoft Word style column rendering - line by line flow with section spacing
function renderInWordStyleColumns(doc, lines, leftColumnX, rightColumnX, columnWidth, pageWidth) {
    const startY = doc.y;
    const bottomMargin = 70; // Match the PDF document bottom margin
    const maxY = doc.page.height - bottomMargin;
    
    let currentX = leftColumnX;  // Start in left column
    let currentY = startY;
    let isRightColumn = false;
    let pageCount = 1; // Track pages manually
    const pageReferences = [doc.page]; // Store page references
    
    console.log(`üì∞ Simple Word-style columns with section spacing: startY=${startY}, maxY=${maxY}`);
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        
        // Calculate height needed for this line
        const lineHeight = doc.currentLineHeight();
        
        // Special handling for section headers - keep them with their content
        if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            // Look ahead to find at least 2-3 lines of content after this header
            let contentLines = 0;
            let totalSectionHeight = lineHeight; // Start with header height
            
            for (let j = i + 1; j < lines.length && contentLines < 3; j++) {
                const nextLine = lines[j].trim();
                if (nextLine === '') {
                    totalSectionHeight += lineHeight * 1.2; // Updated to match rendering spacing
                } else if (nextLine.startsWith('[') && nextLine.endsWith(']')) {
                    break; // Hit another section header, stop looking
                } else {
                    totalSectionHeight += lineHeight;
                    contentLines++;
                }
            }
            
            // Check if header + minimum content will fit in current column
            const willFitWithContent = (currentY + totalSectionHeight) <= maxY;
            
            if (!willFitWithContent && !isRightColumn) {
                console.log(`üîÑ Moving section "${trimmedLine}" to right column (needs ${totalSectionHeight.toFixed(1)}px for header + content)`);
                currentX = rightColumnX;
                currentY = startY;
                isRightColumn = true;
            }
            else if (!willFitWithContent && isRightColumn) {
                console.log(`üìÑ Moving section "${trimmedLine}" to new page (needs ${totalSectionHeight.toFixed(1)}px for header + content)`);
                doc.addPage();
                pageCount++; // Increment page count
                pageReferences.push(doc.page); // Store page reference
                currentX = leftColumnX;
                currentY = startY; // Use startY, not doc.y
                isRightColumn = false;
            }
        }
        // Normal line handling - check if this line will fit in current column
        else {
            const willFitInCurrentColumn = (currentY + lineHeight) <= maxY;
            
            // If line won't fit and we're in left column, switch to right
            if (!willFitInCurrentColumn && !isRightColumn) {
                console.log(`üîÑ Switching to right column at line ${i}: "${trimmedLine.substring(0, 30)}..."`);
                currentX = rightColumnX;
                currentY = startY;
                isRightColumn = true;
            }
            // If line won't fit and we're in right column, new page
            else if (!willFitInCurrentColumn && isRightColumn) {
                console.log(`üìÑ New page needed at line ${i}`);
                doc.addPage();
                pageCount++; // Increment page count
                pageReferences.push(doc.page); // Store page reference
                currentX = leftColumnX;
                currentY = startY; // Use startY, not doc.y
                isRightColumn = false;
            }
        }
        
        // Set position and render the line
        doc.x = currentX;
        doc.y = currentY;
        
        if (trimmedLine === '') {
            // Empty line - spacing (from section spacing feature) - make it more visible
            currentY += lineHeight * 1.2; // Increased from 0.6 to 1.2 for better visibility
            console.log(`üìè Empty line spacing at y=${currentY.toFixed(1)}`);
        } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
            // Section headers - BOLD
            doc.font('Helvetica-Bold');
            doc.text(line, currentX, currentY, { width: columnWidth });
            doc.font('Helvetica');
            currentY = doc.y + (lineHeight * 0.1); // Small space after headers
        } else if (isChordLine(trimmedLine)) {
            // Chord lines - BOLD
            doc.font('Helvetica-Bold');
            doc.text(line, currentX, currentY, { width: columnWidth });
            doc.font('Helvetica');
            currentY = doc.y;
        } else {
            // Lyrics - NORMAL font
            doc.font('Helvetica');
            doc.text(line, currentX, currentY, { width: columnWidth });
            currentY = doc.y;
        }
        
        console.log(`üìù Line ${i}: "${trimmedLine.substring(0, 20)}..." at y=${currentY.toFixed(1)} in ${isRightColumn ? 'RIGHT' : 'LEFT'} column`);
    }
    
    console.log(`‚úÖ Simple Word-style rendering complete. Final position: column=${isRightColumn ? 'right' : 'left'}, y=${currentY}, pages created: ${pageCount}`);
    return { pageCount, pageReferences }; // Return both count and references
}

// Group lines into logical sections with headers staying with their content
function groupChordLyricsPairs(lines) {
    const groups = [];
    let i = 0;
    
    while (i < lines.length) {
        const currentLine = lines[i].trim();
        
        // Section headers - collect header + following content as one group
        if (currentLine.startsWith('[') && currentLine.endsWith(']')) {
            const sectionGroup = {
                type: 'section-block',
                lines: [lines[i]], // Start with header
                hasContent: false
            };
            
            i++; // Move past header
            
            // Collect all content until next section or end
            while (i < lines.length) {
                const nextLine = lines[i].trim();
                
                // Stop if we hit another section header
                if (nextLine.startsWith('[') && nextLine.endsWith(']')) {
                    break;
                }
                
                sectionGroup.lines.push(lines[i]);
                
                // Mark that this section has content (not just empty lines)
                if (nextLine !== '') {
                    sectionGroup.hasContent = true;
                }
                
                i++;
            }
            
            console.log(`üìÇ Section block: "${currentLine}" with ${sectionGroup.lines.length - 1} content lines`);
            groups.push(sectionGroup);
        }
        // Handle orphaned content (content without section header)
        else {
            // For content without a section header, use the old logic
            if (currentLine === '') {
                groups.push({
                    type: 'empty',
                    lines: [lines[i]]
                });
                i++;
            }
            // Chord line - check if next line is lyrics
            else if (isChordLine(currentLine)) {
                const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
                
                if (nextLine && !nextLine.startsWith('[') && !nextLine.endsWith(']') && !isChordLine(nextLine)) {
                    // Chord-lyrics pair
                    groups.push({
                        type: 'chord-lyrics',
                        lines: [lines[i], lines[i + 1]]
                    });
                    i += 2; // Skip both lines
                    console.log(`üéµ Orphaned chord-lyrics pair: "${currentLine}" + "${nextLine}"`);
                } else {
                    // Standalone chord
                    groups.push({
                        type: 'chord',
                        lines: [lines[i]]
                    });
                    i++;
                }
            }
            // Regular lyrics line
            else {
                groups.push({
                    type: 'lyrics',
                    lines: [lines[i]]
                });
                i++;
            }
        }
    }
    
    console.log(`üìä Created ${groups.length} groups from ${lines.length} lines`);
    return groups;
}

// Calculate total height needed for a group
function calculateGroupHeight(doc, group, columnWidth) {
    let totalHeight = 0;
    
    // For section blocks and continuations, we need to be more careful about height calculation
    if (group.type === 'section-block' || group.type === 'section-continuation') {
        for (let i = 0; i < group.lines.length; i++) {
            const line = group.lines[i];
            const trimmedLine = line.trim();
            
            if (trimmedLine === '') {
                totalHeight += doc.currentLineHeight() * 0.5;
            } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                // Section header gets extra space (reduced padding)
                const textHeight = doc.heightOfString(line, { width: columnWidth });
                totalHeight += Math.max(textHeight, doc.currentLineHeight()) + 4; // Reduced from 8 to 4
            } else {
                const textHeight = doc.heightOfString(line, { width: columnWidth });
                totalHeight += Math.max(textHeight, doc.currentLineHeight()) + 1; // Reduced from 3 to 1
            }
        }
        
        // Add some padding for section blocks (reduced)
        totalHeight += 2; // Reduced from 5 to 2
    } else if (group.type === 'section-content') {
        // Special handling for partial section content (used in calculations)
        for (let i = 0; i < group.lines.length; i++) {
            const line = group.lines[i];
            const trimmedLine = line.trim();
            
            if (trimmedLine === '') {
                totalHeight += doc.currentLineHeight() * 0.5;
            } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                const textHeight = doc.heightOfString(line, { width: columnWidth });
                totalHeight += Math.max(textHeight, doc.currentLineHeight()) + 4;
            } else {
                const textHeight = doc.heightOfString(line, { width: columnWidth });
                totalHeight += Math.max(textHeight, doc.currentLineHeight()) + 1;
            }
        }
        totalHeight += 2;
    } else {
        // Original logic for other group types
        for (const line of group.lines) {
            const trimmedLine = line.trim();
            
            if (trimmedLine === '') {
                totalHeight += doc.currentLineHeight() * 0.5;
            } else {
                const textHeight = doc.heightOfString(line, { width: columnWidth });
                totalHeight += Math.max(textHeight, doc.currentLineHeight()) + 1; // Reduced from 3 to 1
            }
        }
        
        // Add extra space for section headers (reduced)
        if (group.type === 'section') {
            totalHeight += 4; // Reduced from 8 to 4
        }
        
        // Add small gap between chord-lyrics pairs
        if (group.type === 'chord-lyrics') {
            totalHeight += 1; // Reduced from 2 to 1
        }
    }
    
    return totalHeight;
}

// Render a complete group (keeping related content together)
function renderGroup(doc, group, x, startY, columnWidth) {
    let currentY = startY;
    
    // Handle section blocks and section continuations specially
    if (group.type === 'section-block' || group.type === 'section-continuation') {
        console.log(`üìã Rendering ${group.type} with ${group.lines.length} lines`);
        
        for (let i = 0; i < group.lines.length; i++) {
            const line = group.lines[i];
            const trimmedLine = line.trim();
            
            doc.x = x;
            doc.y = currentY;
            
            if (trimmedLine === '') {
                currentY += doc.currentLineHeight() * 0.5;
            } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                // Section header - bold with extra space
                console.log(`üìå Section header: "${trimmedLine}"`);
                doc.font('Helvetica-Bold');
                const beforeY = currentY;
                doc.text(line, x, currentY, { width: columnWidth });
                const afterY = doc.y;
                doc.font('Helvetica');
                currentY = beforeY + Math.max(afterY - beforeY, doc.currentLineHeight()) + 4; // Reduced from 8 to 4
            } else if (isChordLine(trimmedLine)) {
                // Chord line in section
                doc.font('Helvetica-Bold');
                const beforeY = currentY;
                doc.text(line, x, currentY, { width: columnWidth });
                const afterY = doc.y;
                doc.font('Helvetica');
                currentY = beforeY + Math.max(afterY - beforeY, doc.currentLineHeight()) + 1; // Reduced from 3 to 1
            } else {
                // Lyrics line in section
                doc.font('Helvetica');
                const beforeY = currentY;
                doc.text(line, x, currentY, { width: columnWidth });
                const afterY = doc.y;
                currentY = beforeY + Math.max(afterY - beforeY, doc.currentLineHeight()) + 1; // Reduced from 3 to 1
            }
        }
        
        // Add some space after section block (reduced)
        currentY += 2; // Reduced from 5 to 2
    } else {
        // Original rendering for other group types
        for (let i = 0; i < group.lines.length; i++) {
            const line = group.lines[i];
            const trimmedLine = line.trim();
            
            doc.x = x;
            doc.y = currentY;
            
            if (trimmedLine === '') {
                currentY += doc.currentLineHeight() * 0.5;
            } else if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                // Section header
                doc.font('Helvetica-Bold');
                const beforeY = currentY;
                doc.text(line, x, currentY, { width: columnWidth });
                const afterY = doc.y;
                doc.font('Helvetica');
                currentY = beforeY + Math.max(afterY - beforeY, doc.currentLineHeight()) + 4; // Reduced from 8 to 4
            } else if (isChordLine(trimmedLine)) {
                // Chord line
                doc.font('Helvetica-Bold');
                const beforeY = currentY;
                doc.text(line, x, currentY, { width: columnWidth });
                const afterY = doc.y;
                doc.font('Helvetica');
                currentY = beforeY + Math.max(afterY - beforeY, doc.currentLineHeight()) + 1; // Reduced from 3 to 1
            } else {
                // Lyrics line
                doc.font('Helvetica');
                const beforeY = currentY;
                doc.text(line, x, currentY, { width: columnWidth });
                const afterY = doc.y;
                currentY = beforeY + Math.max(afterY - beforeY, doc.currentLineHeight()) + 1; // Reduced from 3 to 1
            }
        }
        
        // Add small gap after chord-lyrics pairs (reduced)
        if (group.type === 'chord-lyrics') {
            currentY += 1; // Reduced from 2 to 1
        }
    }
    
    return currentY;
}

// Check if a line contains chords - Simplified and more accurate
function isChordLine(line) {
    const trimmed = line.trim();
    
    // Empty lines are not chord lines
    if (trimmed.length === 0) return false;
    
    // Section headers are not chord lines
    if (trimmed.startsWith('[') && trimmed.endsWith(']')) return false;
    
    // Simple chord patterns - much more permissive
    const basicChordPattern = /\b[A-G][#b]?(m|maj|min|sus|aug|dim|add|[0-9])*\b/g;
    const chordMatches = trimmed.match(basicChordPattern);
    
    if (!chordMatches) return false;
    
    // Count words in the line
    const words = trimmed.split(/\s+/).filter(word => word.length > 0);
    const chordCount = chordMatches.length;
    
    // Very simple rules:
    // 1. If more than half the words are chords, it's a chord line
    // 2. If it's a short line (‚â§ 20 chars) with any chords, it's probably chords
    // 3. If it has 2+ chords and no common lyrics words, it's chords
    
    const chordRatio = chordCount / words.length;
    const isShort = trimmed.length <= 20;
    const hasCommonLyrics = /\b(the|and|you|me|my|i|a|to|in|is|of|for|with|will|love|lord|jesus|your|than|all|name)\b/i.test(trimmed);
    
    // Chord line if:
    return (chordRatio >= 0.5) ||                    // More than half words are chords
           (isShort && chordCount >= 1) ||          // Short line with any chords
           (chordCount >= 2 && !hasCommonLyrics);   // Multiple chords, no lyrics words
}

module.exports = {
    generatePDF,
    isChordLine
};
